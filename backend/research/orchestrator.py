"""
Deep Research Orchestrator.
Implements the core event-driven research loop using LlamaIndex Workflows.
"""

from typing import List, Optional, Union

from llama_index.core.workflow import (
    Workflow,
    Context,
    StartEvent,
    StopEvent,
    step,
)

from backend.research.state import ResearchState, WorkerState
from backend.research.events import (
    PlanCreatedEvent,
    WorkerStartEvent,
    WorkerResultEvent,
    IterationCompleteEvent,
)
from backend.research import activities


class DeepResearchWorkflow(Workflow):
    """
    Orchestrates the iterative research process.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @step
    async def start(self, ctx: Context, ev: StartEvent) -> PlanCreatedEvent:
        """
        Initializes the research state and generates the initial plan.
        """
        topic = ev.get("topic")
        if not topic:
            raise ValueError("Topic is required to start research.")

        # Initialize global state in Context
        state = ResearchState(topic=topic, status="running")
        # Save initial state to Context (and potentially DB)
        await ctx.store.set("state", state)

        # Log start
        state.logs.append("Workflow initialized.")
        await activities.save_state(state)

        # Generate Initial Plan (Agentic Step)
        plan = await activities.generate_initial_plan(topic)
        state.plan = plan
        state.logs.append(f"Plan generated: {plan.current_hypothesis}")

        # Initialize workers from plan
        for worker_cfg in plan.initial_workers:
            # Create WorkerState objects (ID preserved if provided, or generated by default)
            w_state = WorkerState(
                id=worker_cfg.worker_id, strategy=worker_cfg.strategy, status="active"
            )
            state.workers[w_state.id] = w_state

        await activities.save_state(state)

        return PlanCreatedEvent(plan=plan)

    @step
    async def dispatch(
        self, ctx: Context, ev: Union[PlanCreatedEvent, IterationCompleteEvent]
    ) -> Optional[WorkerStartEvent]:
        """
        Fan-Out: Dispatches work to all active workers.
        """
        state: ResearchState = await ctx.store.get("state")

        # Identify active workers (including those categorized as productive or declining)
        active_workers = [
            w
            for w in state.workers.values()
            if w.status in ["active", "PRODUCTIVE", "DECLINING"]
        ]

        if not active_workers:
            # No viable workers left to dispatch. Transition to completed.
            state.status = "completed"
            state.logs.append("No active or productive workers remaining. Stopping.")
            await activities.save_state(state)
            ctx.send_event(StopEvent(result=state))
            return None

        # Send an event for EACH active worker
        for worker in active_workers:
            ctx.send_event(WorkerStartEvent(worker_state=worker))

        # We return None because we used send_event to emit multiple events
        return None

    @step(num_workers=10)
    async def execute_worker(
        self, ctx: Context, ev: WorkerStartEvent
    ) -> WorkerResultEvent:
        """
        Executes a single worker's iteration in parallel.
        """
        # Execute the activity (IO bound)
        # This calls the implementation in activities.py
        result = await activities.execute_worker_iteration(ev.worker_state)

        return WorkerResultEvent(
            worker_id=ev.worker_state.id,
            pages_fetched=result.get("pages_fetched", 0),
            entities_found=result.get("entities_found", 0),
            new_entities=result.get("new_entities", 0),
            novelty_rate=result.get("novelty_rate", 0.0),
            status=result.get("status", "PRODUCTIVE"),
        )

    @step
    async def aggregate(
        self, ctx: Context, ev: WorkerResultEvent
    ) -> Union[IterationCompleteEvent, StopEvent]:
        """
        Fan-In: Aggregates results from all workers, checks stopping criteria, and updates plan.
        """
        state: ResearchState = await ctx.store.get("state")
        active_worker_count = len(
            [
                w
                for w in state.workers.values()
                if w.status in ["active", "PRODUCTIVE", "DECLINING"]
            ]
        )

        # Wait for ALL active workers to return results
        events = ctx.collect_events(ev, [WorkerResultEvent] * active_worker_count)
        if events is None:
            return None

        # All workers finished this iteration
        worker_results: List[WorkerResultEvent] = events

        # --- Critical Section: State Update ---
        # Update metrics and worker status based on results

        total_new_entities = 0
        total_pages = 0
        for res in worker_results:
            w_state = state.workers.get(res.worker_id)
            if w_state:
                w_state.pages_fetched += res.pages_fetched
                w_state.entities_found += res.entities_found
                w_state.new_entities += res.new_entities
                w_state.status = res.status
                total_new_entities += res.new_entities
                total_pages += res.pages_fetched

        iteration = state.logs.count("Iteration completed") + 1
        global_novelty = total_new_entities / max(total_pages, 1)
        state.logs.append(
            f"Iteration {iteration} completed. Found {total_new_entities} new entities. Global Novelty: {global_novelty:.2%}"
        )

        # --- Stopping Criteria Check ---
        # 1. Budget exhausted? (Stub check)
        # 2. Novelty low? (Stub check)
        # 3. Max iterations? (For now, hard stop at 5 for safety)
        if iteration >= 5:
            state.status = "completed"
            await activities.save_state(state)
            return StopEvent(result=state)

        # Iterate Planning (Adaptive Step)
        # We call the agentic update logic to potentially spawn new workers or kill existing ones
        new_plan = await activities.update_plan(state)
        state.plan = new_plan

        # Sync worker states if the plan changed (e.g. killed workers)
        # In a real implementation, the plan would specify which workers to shutdown
        # For now, we rely on the status update from the result event

        await activities.save_state(state)

        return IterationCompleteEvent(
            iteration=iteration,
            summary=f"Finished iteration {iteration}",
            global_novelty_rate=global_novelty,
        )
